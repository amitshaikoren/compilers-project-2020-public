/*************/
/* Based on a template by Oren Ish-Shalom */
/*************/


/*************/
/* IMPORTS */
/*************/

import java_cup.runtime.*;
import ast.*;
import java.util.List;
import java.util.LinkedList;

parser code
{:
	public Lexer lexer;

	public Parser(Lexer lexer)
	{
		super(lexer);
		this.lexer = lexer;
	}

	// Override default error reporting in parser
	public void report_error(String message, Object info)
	{
	    System.err.print("Syntax error at line " + lexer.getLine() + " of input. Parser\n");
		System.exit(1);
	}
:}

/************************/
/* CUSTOMIZE CUP PARSER */
/************************/
scan with
{:
	Symbol s;
    try {
	s = lexer.next_token();
	// System.out.print(s.sym);
	// System.out.print("[");
	// System.out.print(lexer.getLine());
	// System.out.print(":");
	// System.out.print(lexer.getCharPos());
	// System.out.print("] ");
	// System.out.print(sym.terminalNames[s.sym]);
	// if (s.value != null)
	// {
	//	System.out.print("( ");
	//	System.out.print(s.value);
	//	System.out.print(" )");
	// }
	// System.out.print("\n");
	return s;
     } catch (java.lang.Error e) {
         System.err.print("Syntax error at line " + lexer.getLine() + " of input. Lexer\n");
         System.exit(1);
         return null;
     }
:};

/*************/
/* TERMINALS */
/*************/
terminal PUBLIC,STATIC,VOID,MAIN,STRING;
terminal LPAREN,RPAREN,LCPAREN,RCPAREN,LSPAREN,RSPAREN;
terminal CLASS,EXTENDS;
terminal RETURN;
terminal SEMICOLON;
terminal INT,BOOLEAN;
terminal IF,ELSE,WHILE;
terminal PRINT;
terminal EQUALS,AND,LT,PLUS,MINUS,MULT;
terminal DOT,COMMA;
terminal LENGTH;
terminal TRUE,FALSE;
terminal THIS;
terminal NEW;
terminal NOT;
terminal int NUMBER;
terminal String ID;
terminal EOF;


/*****************/
/* NON TERMINALS */
/*****************/
non terminal Program prog;
non terminal MainClass mainClass;
non terminal ClassDecleration classDecleration;
non terminal LinkedList<ClassDecleration> classDeclerationList;
non terminal EXTEND extend;
non terminal Nothing nothing;
non terminal VarDecleration varDecleration;
non terminal LinkedList<VarDecleration> varDeclerationList;
non terminal MethodDecleration methodDecleration;
non terminal LinkedList<MethodDecleration> methodDeclerationList;
non terminal TYPE type;
non terminal Formals formals;
non terminal FormalArgs formalArgs;
non terminal LinkedList<FormalArgs> formalArgsList;
non terminal Vars vars;
non terminal Methods methods;
non terminal Statements statements;
non terminal Statement statement;
non terminal LinkedList<Statement> statementList;
non terminal EXP exp;


/*
non terminal ClassDecl classDecl;
non terminal LinkedList<ClassDecl> ClassDeclList;
non terminal VarDecl varDecl;
non terminal LinkedList<VarDecl> fieldDeclList;
non terminal MethodDecl methodDecl;
non terminal LinkedList<MethodDecl> methodDeclList;
non terminal MainClass mainClass;
non terminal FormalArg formalArg;
non terminal LinkedList<FormalArg> formalArgList;
non terminal LinkedList<Statement> statementList;
non terminal BlockStatement blockStatement;
non terminal IfStatement ifStatement;
non terminal WhileStatement whileStatement;
non terminal SysoutStatement sysoutStatement;
non terminal AssignStatement assignStatement;
non terminal AssignArrayStatement assignArrayStatement;
non terminal AndExpr e;
non terminal LtExpr e;
non terminal AddExpr e;
non terminal SubtractExpr e;
non terminal MultExpr e;
non terminal ArrayAccessExpr e;
non terminal ArrayLengthExpr e;
non terminal MethodCallExpr e;
non terminal IntegerLiteralExpr e;
non terminal TrueExpr e;
non terminal FalseExpr e;
non terminal IdentifierExpr e;
non terminal ThisExpr e;
non terminal NewIntArrayExpr e;
non terminal NewObjectExpr e;
non terminal NotExpr e;
non terminal IntAstType t;
non terminal BoolAstType t;
non terminal IntArrayAstType t;
non terminal RefType t;
*/

/***********************/
/* OPERATOR PRECEDENCE */
/***********************/

/************************/
/* INITIAL NON TERMINAL */
/************************/
start with prog;

/********************/
/* PRODUCTION RULES */
/********************/

prog              ::=  mainClass:m  classDeclerationList:c1 EOF  {: RESULT = new Program(m, c1); :};
mainClass         ::=  CLASS ID:i1 LCPAREN PUBLIC STATIC VOID MAIN LPAREN STRING LSPAREN RSPAREN ID:i2 RPAREN LCPAREN Statement:s RCPAREN RCPAREN  {: RESULT = new MainClass(i1, i2, s); :};
classDecleration  ::=  CLASS ID:i1 extend:i2 LCPAREN LPAREN vars:v RPAREN LPAREN methods:m RPAREN RCPAREN {: RESULT = new ClassDecl(i1,i2,v,m); :};
extend            ::=  LPAREN EXTENDS ID:id2 RPAREN {: RESULT = id2; :}
                       |  /* empty */    {: RESULT = Null; :};
vars              ::=  varDeclerationList:v {: RESULT = *************************************; :}
                       |/* empty */     {: RESULT = Null; :};
methods           ::=  methodDeclerationList:m {: RESULT = *************************************; :}
                       |/* empty */     {: RESULT = Null; :};
varDecleration    ::=  type:t ID:id SEMICOLON  {: RESULT = new VarDecl(t, id); :};
type              ::=  INT
                       | BOOLEAN
                       | INT LSPAREN RSPAREN
                       | ID:id  {: RESULT = id; :};
methodDecleration ::=  PUBLIC type:t ID:i1 LPAREN formals:f RPAREN LCPAREN vars:v statements:st RETURN exp:e SEMICOLON RCPAREN  {: RESULT = new MethodDecl(t,i1,f,v,st,e); :};
formals           ::=  formalArgList:f {: RESULT = *************************************; :}
                       | /* empty */    {: RESULT = Null; :};
formalArg         ::=
statements        ::= statementList:st  {: RESULT = *************************************; :}
                      |/* empty */     {: RESULT = Null; :};
